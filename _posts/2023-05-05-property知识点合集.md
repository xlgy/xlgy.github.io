---
layout:     post
title:      property知识点合集
subtitle:   property知识点合集
date:       2023-05-05
author:     LXY
header-img: img/home1.jpeg
catalog: true
tags:
    - iOS
---


# property 修饰符

**readonly**
此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用**@synthesize**关键字，也是有**get方法**被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。

**readwrite**
此标记说明属性会被当成读写的，这也是**默认修饰符**。设置器和读取器都需要在@implementation中实现。如果使用**@synthesize**关键字，**get**和**set**方法都会被解析。

**assign**
此标记说明设置器直接进行赋值，这也是**默认值**。在使用垃圾收集的应用程序中，如果你要一个属性使用assign，且这个类符合NSCopying协议，你就要明确指出这个标记，而不是简单地使用默认值，否则的话，你将得到一个编译警告。这再次向编译器说明你确实需要赋值，即使它是可拷贝的。

**strong、weak**
默认strong
strong表示属性对所赋的值持有强引用表示一种“拥有关系”(owning relationship)，会先保留新值即增加新值的引用计数，然后再释放旧值即减少旧值的引用计数。只能修饰对象。如果对一些对象需要保持强引用则使用strong。

weak表示对所赋的值对象持有弱引用表示一种“非拥有关系”(nonowning relationship)，对新值不会增加引用计数，也不会减少旧值的引用计数。所赋的值在引用计数为0被销毁后，weak修饰的属性会被自动置为nil能够有效防止野指针错误。
weak常用在修饰delegate等防止循环引用的场景。



**copy**
它指出，在赋值时使用传入值的一份拷贝。拷贝工作由copy方法执行，此属性只对那些实行了NSCopying协议的对象类型有效。
**注意：如果是可变数组的属性使用此修饰符会变成不可变数组，容易造成crash**

**atomic/nonatomic**
**默认值：atomic**
指定合成存取方法是否为原子操作，可以理解为是否线程安全，但在iOS上即时使用atomic也不一定是线程安全的，要保证线程安全需要使用锁机制，超过本文的讲解范围，可以自行查阅。
可以发现几乎所有代码的属性设置都会使用nonatomic，这样能够提高访问性能，在iOS中使用锁机制的开销较大，会损耗性能。

**结论：基本数据默认的关键字是 atomic、readwrite、assign，普通的 OC 对象: atomic、readwrite、strong。**

# @property、@synthesize和@dynamic

**@property的本质：**
```
@property = ivar(实例变量) + getter/setter（存取方法）;
```
完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。

我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.

@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果@synthesize 和 @dynamic都没写，那么默认的就是@syntheszie var = _var;

**@synthesize**
@synthesize表示如果属性没有手动实现setter和getter方法，编译器会自动加上这两个方法。

**@dynamic**
@dynamic告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。假如一个属性被声明为@dynamic var，而且你没有提供@setter 方法和@getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

