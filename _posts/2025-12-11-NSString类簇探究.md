---
layout:     post
title:      NSString类簇探究
subtitle:   NSString类簇探究
date:       2025-12-11
author:     LXY
header-img: img/home1.jpeg
catalog: true
tags:
    - iOS
---




# 前言

在 Objective-C 的 Foundation 框架中 NSString 对象是很复杂的存在，使用了抽象工厂模式，因此 NSString 其实是多个类簇组合成的抽象类，不同的创建方式以及不同的字符长度都可能影响最终得到的类簇类型，今天就来研究一下 NSString 下复杂的类簇。


# 一、NSString定义


我们初始化一个NSString时，有多种方式实现

## 1. 字面量

这种方式是平时开发中比较常用的初始化字符串的方式，因为语法简介明了

```
    ///>短字面量
    NSString *s_zml = @"a";
    stringDic[@"短字面量"] = s_zml;
    [stringArr addObject:@"短字面量"];
    ///>长字面量
    NSString *l_zml = @"testString_testString";
    stringDic[@"长字面量"] = l_zml;
    [stringArr addObject:@"长字面量"];
```

## 2. stringWithString / initWithString

[NSString stringWithString: ]	实际封装的语法糖，它是对[ [NSString alloc]initWithString:]的封装

```
    ///>长stringWithString
    NSString *string_string1 = [NSString stringWithString:@"testString_testString"];
    stringDic[@"长stringWithString"] = string_string1;
    [stringArr addObject:@"长stringWithString"];
    ///>短stringWithString
    NSString *string_string2 = [NSString stringWithString:@"a"];
    stringDic[@"短stringWithString"] = string_string2;
    [stringArr addObject:@"短stringWithString"];
    ///>长initWithString
    NSString *init_string1 = [[NSString alloc]initWithString:@"testString_testString"];
    stringDic[@"长initWithString"] = init_string1;
    [stringArr addObject:@"长initWithString"];
    ///>短initWithString
    NSString *init_string2 = [[NSString alloc]initWithString:@"a"];
    stringDic[@"短initWithString"] = init_string2;
    [stringArr addObject:@"短initWithString"];
```


## 3. stringWithFormat / initWithFormat

[NSString stringWithFormat: ]	实际封装的语法糖，它是对[ [NSString alloc]initWithFormat:]的封装

```
    ///>长stringWithFormat
    NSString *string_format1= [NSString stringWithFormat:@"testString_testString"];
    stringDic[@"长stringWithFormat"] = string_format1;
    [stringArr addObject:@"长stringWithFormat"];
    ///>短stringWithFormat
    NSString *string_format2= [NSString stringWithFormat:@"a"];
    stringDic[@"短stringWithFormat"] = string_format2;
    [stringArr addObject:@"短stringWithFormat"];
    ///>长initWithFormat
    NSString *init_format1= [[NSString alloc]initWithFormat:@"testString_testString"];
    stringDic[@"长initWithFormat"] = init_format1;
    [stringArr addObject:@"长initWithFormat"];
    ///>短initWithFormat
    NSString *init_format2= [[NSString alloc]initWithFormat:@"a"];
    stringDic[@"短initWithFormat"] = init_format2;
    [stringArr addObject:@"短initWithFormat"];
```






# 二、代码实验

在 OC中，NSString类型有三种实现方式，分别是:

```
__NSCFConstantString
__NSCFString
NSTaggedPointerString
```

***那这三种类型如何被定义出来及差异性在哪里？***

**一“码”当先**

```
    ///>短字面量
    NSString *s_zml = @"a";
    stringDic[@"短字面量"] = s_zml;
    [stringArr addObject:@"短字面量"];
    ///>长字面量
    NSString *l_zml = @"testString_testString";
    stringDic[@"长字面量"] = l_zml;
    [stringArr addObject:@"长字面量"];
    ///>长stringWithString
    NSString *string_string1 = [NSString stringWithString:@"testString_testString"];
    stringDic[@"长stringWithString"] = string_string1;
    [stringArr addObject:@"长stringWithString"];
    ///>短stringWithString
    NSString *string_string2 = [NSString stringWithString:@"a"];
    stringDic[@"短stringWithString"] = string_string2;
    [stringArr addObject:@"短stringWithString"];
    ///>长initWithString
    NSString *init_string1 = [[NSString alloc]initWithString:@"testString_testString"];
    stringDic[@"长initWithString"] = init_string1;
    [stringArr addObject:@"长initWithString"];
    ///>短initWithString
    NSString *init_string2 = [[NSString alloc]initWithString:@"a"];
    stringDic[@"短initWithString"] = init_string2;
    [stringArr addObject:@"短initWithString"];
    ///>长stringWithFormat
    NSString *string_format1= [NSString stringWithFormat:@"testString_testString"];
    stringDic[@"长stringWithFormat"] = string_format1;
    [stringArr addObject:@"长stringWithFormat"];
    ///>短stringWithFormat
    NSString *string_format2= [NSString stringWithFormat:@"a"];
    stringDic[@"短stringWithFormat"] = string_format2;
    [stringArr addObject:@"短stringWithFormat"];
    ///>长initWithFormat
    NSString *init_format1= [[NSString alloc]initWithFormat:@"testString_testString"];
    stringDic[@"长initWithFormat"] = init_format1;
    [stringArr addObject:@"长initWithFormat"];
    ///>短initWithFormat
    NSString *init_format2= [[NSString alloc]initWithFormat:@"a"];
    stringDic[@"短initWithFormat"] = init_format2;
    [stringArr addObject:@"短initWithFormat"];
        
    for (NSString *key in stringArr) {
        NSString *s = stringDic[key];
        NSLog(@"%@  %@ -> %@  -> %p", key, s, NSStringFromClass([s class]),s);
    }
```


运行代码查看日志


```
短字面量  a -> __NSCFConstantString  -> 0x102a200b0
长字面量  testString_testString -> __NSCFConstantString  -> 0x102a200f0
长stringWithString  testString_testString -> __NSCFConstantString  -> 0x102a200f0
短stringWithString  a -> __NSCFConstantString  -> 0x102a200b0
长initWithString  testString_testString -> __NSCFConstantString  -> 0x102a200f0
短initWithString  a -> __NSCFConstantString  -> 0x102a200b0
长stringWithFormat  testString_testString -> __NSCFString  -> 0x600000c2ba20
短stringWithFormat  a -> NSTaggedPointerString  -> 0xa2d9fdcf77acbed4
长initWithFormat  testString_testString -> __NSCFString  -> 0x600000c2a8b0
短initWithFormat  a -> NSTaggedPointerString  -> 0xa2d9fdcf77acbed4
```


通过日志，我们发现一下结论：
 
 1. 字面量、stringWithString / initWithString 两种初始化方式定义出来的字符串变量都是**__NSCFConstantString** 类型，无论字符串长还是短都是统一类型
 2. stringWithFormat / initWithFormat 初始化字符串会生成两种类型 **__NSCFString、NSTaggedPointerString**，长字符串类型为**__NSCFString**，短子复产类型为**__NSCFString**
 3. 如果字符串内容一致，**__NSCFConstantString**类型和**NSTaggedPointerString**的字符串地址相同，初始化时不会重新开辟内存
 4. **__NSCFString**初始化一定会开发内存地址，即使字符串内容相同，地址也不一致

# 三、理解实现方式

## __NSCFConstantString

我们可以对这个类型的通俗理解就是常量字符串。
在OC中，字符串字面量（例如@“Hello”）被视为常量，并存储在常量数据区域。它被看作是一种编译时常量。它用于表示字符串字面量，这些字符串在编译时就被确定，并在运行时作为常量存储在常量数据区域。
编译器会将字符串字面量优化为常量，在编译时就确定其内容，并将其存储在可执行文件的常量数据区域。
这样做的好处是可以提高字符串的访问效率，并且节省内存空间，因为每个相同的字符串字面量只需要存储一份，也就是为什么内容一致时初始化出来的地址是相等的。
如果我们尝试打印这个类型的引用计数：

```
    for (NSString *key in stringArr) {
        NSString *s = stringDic[key];
        NSLog(@"%@  %@ -> %@  -> %p -> %lu", key, s, NSStringFromClass([s class]),s, (unsigned long)[s retainCount]);
    }

```

我们先看 **__NSCFConstantString**类型的日志输出：

```
短字面量  a -> __NSCFConstantString  -> 0x1007e00b0 -> 18446744073709551615
长字面量  testString_testString -> __NSCFConstantString  -> 0x1007e00f0 -> 18446744073709551615
长stringWithString  testString_testString -> __NSCFConstantString  -> 0x1007e00f0 -> 18446744073709551615
短stringWithString  a -> __NSCFConstantString  -> 0x1007e00b0 -> 18446744073709551615
长initWithString  testString_testString -> __NSCFConstantString  -> 0x1007e00f0 -> 18446744073709551615
短initWithString  a -> __NSCFConstantString  -> 0x1007e00b0 -> 18446744073709551615
```

引用计数为：18446744073709551615，其实是 -1 的无符号表示，表示：这个对象是不可释放的（常量对象），印证了上述结论


### 结论：

1. 对于 NSString 对象来讲，使用s字面量、stringWithString / initWithString 初始化定义字符串，的时候会自动成为 **__NSCFConstantString** 类型。
2. 内容相同的**__NSCFConstantString** 内存也是一样的，**__NSCFConstantString** 是一种常量对象，引用计数无穷大，不会被释放

## NSTaggedPointerString

当我们使用stringWithFormat / initWithFormat 初始化较短字符串时生成该NSTaggedPointerString类型，NSTaggedPointerString 是一种特殊类型的字符串，在 Objective-C 中用于表示较短的字符串对象。

TaggedPointer的意思是标签指针，这是苹果在 64 位环境下对 NSString,NSNumber等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8个字节，位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。

实验代码：
使用stringWithFormat / initWithFormat 初始化定义两个字符串，一个为“ABCDEFGHI”，一个长度为“ABCDEFGHIJ”，我们我们分别看一下两个字符串的类型

```
    NSString *string_format_a= [NSString stringWithFormat:@"ABCDEFGHI"];
    NSLog(@"%@ -> %@", string_format_a, NSStringFromClass([string_format_a class]));
    
    NSString *string_format_b= [NSString stringWithFormat:@"ABCDEFGHIJ"];
    NSLog(@"%@ -> %@", string_format_b, NSStringFromClass([string_format_b class]));
```

打印：

```
ABCDEFGHI -> NSTaggedPointerString
ABCDEFGHIJ -> __NSCFString
```

实例表示**NSTaggedPointerString **类型字符串的最大长度时9，超出则变为**__NSCFString**

其实**NSTaggedPointerString** 的最大可编码字符数不是固定的，它取决于
CPU 架构 + iOS 版本 + Foundation 实现。有的系统能编码 9 个字符，有的只能 7 个


64 位指针结构示意：

```
| tag bit | type bits | subtype bits | payload bits |
```

随着 iOS 演进：

- type bits 压缩（占更少空间）
- subtype bits 重排
- payload bit 数量增加

最新系统 payload 位数能达到 ~63 - (tag/type/meta) ≈ 60 bits
60 bits / 8 = 7.5 字节 → 可以存 7~9 字符，视编码而定。

Apple 不断优化 tagged pointer，是为了性能与内存占用最佳化。

### 结论：

1. 对于 NSString 对象来讲，使用stringWithFormat / initWithFormat 初始化定义字符串，数字、英文字母字符串的长度小于等于 (较新新系统为9，之前系统可能为7) 的时候会自动成为 **NSTaggedPointerString** 类型。
2. 内容相同的**NSTaggedPointerString**内存也是一样的，**NSTaggedPointerString**也是一种常量对象，引用计数无穷大，不会被释放

## __NSCFString

和前两者不同， __NSCFString 对象是在运行时创建的一种 NSString 子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。

通过 stringWithFormat / initWithFormat 初始化较长的时字符串会生成**__NSCFString**类型

查看之前代码的日志：

```
长stringWithFormat  testString_testString -> __NSCFString  -> 0x600000c2ba20  -> 2
长initWithFormat  testString_testString -> __NSCFString  -> 0x600000c2a8b0  -> 2
```

可以看出即使字符串内容相同，地址也不一样，并且引用计数不是无穷大，说明字符串不是常量对象

### 结论：

1. 对于 NSString 对象来讲，使用stringWithFormat / initWithFormat 初始化定义字符串，数字、英文字母字符串的长度大于 (较新新系统为9，之前系统可能为7) 的时候会自动成为 **__NSCFString** 类型。
2. 内容相同的**__NSCFString** 内存不是一样的， **__NSCFString** 不是一种常量对象，引用计数会根据被持有数增加，当引用计数为0时会被ARC释放

# 四、三种类型的拷贝


直接上实例代码：

```
    NSMutableDictionary *stringDic = @{}.mutableCopy;
    NSMutableArray *stringArr = @[].mutableCopy;

    ///>短字面量
    NSString *s_zml = @"a";
    stringDic[@"短字面量"] = s_zml;
    [stringArr addObject:@"短字面量"];
    ///>长字面量
    NSString *l_zml = @"testString_testString";
    stringDic[@"长字面量"] = l_zml;
    [stringArr addObject:@"长字面量"];
    ///>长stringWithString
    NSString *string_string1 = [NSString stringWithString:@"testString_testString"];
    stringDic[@"长stringWithString"] = string_string1;
    [stringArr addObject:@"长stringWithString"];
    ///>短stringWithString
    NSString *string_string2 = [NSString stringWithString:@"a"];
    stringDic[@"短stringWithString"] = string_string2;
    [stringArr addObject:@"短stringWithString"];
    ///>长initWithString
    NSString *init_string1 = [[NSString alloc]initWithString:@"testString_testString"];
    stringDic[@"长initWithString"] = init_string1;
    [stringArr addObject:@"长initWithString"];
    ///>短initWithString
    NSString *init_string2 = [[NSString alloc]initWithString:@"a"];
    stringDic[@"短initWithString"] = init_string2;
    [stringArr addObject:@"短initWithString"];
    ///>长stringWithFormat
    NSString *string_format1= [NSString stringWithFormat:@"testString_testString"];
    stringDic[@"长stringWithFormat"] = string_format1;
    [stringArr addObject:@"长stringWithFormat"];
    ///>短stringWithFormat
    NSString *string_format2= [NSString stringWithFormat:@"a"];
    stringDic[@"短stringWithFormat"] = string_format2;
    [stringArr addObject:@"短stringWithFormat"];
    ///>长initWithFormat
    NSString *init_format1= [[NSString alloc]initWithFormat:@"testString_testString"];
    stringDic[@"长initWithFormat"] = init_format1;
    [stringArr addObject:@"长initWithFormat"];
    ///>短initWithFormat
    NSString *init_format2= [[NSString alloc]initWithFormat:@"a"];
    stringDic[@"短initWithFormat"] = init_format2;
    [stringArr addObject:@"短initWithFormat"];
        
    for (NSString *key in stringArr) {
        NSString *s = stringDic[key];
        NSLog(@"%@  %@ -> %@  -> %p -> %lu", key, s, NSStringFromClass([s class]),s, (unsigned long)[s retainCount]);
        NSString *sCopy = [s copy];
        NSLog(@"浅拷贝后：%@  %@ -> %@  -> %p -> %lu", key, sCopy, NSStringFromClass([sCopy class]),sCopy,(unsigned long)[sCopy retainCount]);
        
        NSString *sMCopy = [s mutableCopy];
        NSLog(@"深拷贝后：%@  %@ -> %@  -> %p -> %lu", key, sMCopy, NSStringFromClass([sMCopy class]),sMCopy,(unsigned long)[sMCopy retainCount]);
    }
```

打印日志：

```
短字面量  a -> __NSCFConstantString  -> 0x10491c0b0 -> 18446744073709551615
浅拷贝后：短字面量  a -> __NSCFConstantString  -> 0x10491c0b0 -> 18446744073709551615
深拷贝后：短字面量  a -> __NSCFString  -> 0x600000c38c90 -> 1
长字面量  testString_testString -> __NSCFConstantString  -> 0x10491c0f0 -> 18446744073709551615
浅拷贝后：长字面量  testString_testString -> __NSCFConstantString  -> 0x10491c0f0 -> 18446744073709551615
深拷贝后：长字面量  testString_testString -> __NSCFString  -> 0x600000c38a20 -> 1
长stringWithString  testString_testString -> __NSCFConstantString  -> 0x10491c0f0 -> 18446744073709551615
浅拷贝后：长stringWithString  testString_testString -> __NSCFConstantString  -> 0x10491c0f0 -> 18446744073709551615
深拷贝后：长stringWithString  testString_testString -> __NSCFString  -> 0x600000c29c80 -> 1
短stringWithString  a -> __NSCFConstantString  -> 0x10491c0b0 -> 18446744073709551615
浅拷贝后：短stringWithString  a -> __NSCFConstantString  -> 0x10491c0b0 -> 18446744073709551615
深拷贝后：短stringWithString  a -> __NSCFString  -> 0x600000c29fe0 -> 1
长initWithString  testString_testString -> __NSCFConstantString  -> 0x10491c0f0 -> 18446744073709551615
浅拷贝后：长initWithString  testString_testString -> __NSCFConstantString  -> 0x10491c0f0 -> 18446744073709551615
深拷贝后：长initWithString  testString_testString -> __NSCFString  -> 0x600000c2a220 -> 1
短initWithString  a -> __NSCFConstantString  -> 0x10491c0b0 -> 18446744073709551615
浅拷贝后：短initWithString  a -> __NSCFConstantString  -> 0x10491c0b0 -> 18446744073709551615
深拷贝后：短initWithString  a -> __NSCFString  -> 0x600000c2a2e0 -> 1
长stringWithFormat  testString_testString -> __NSCFString  -> 0x600000c38780 -> 2
浅拷贝后：长stringWithFormat  testString_testString -> __NSCFString  -> 0x600000c38780 -> 3
深拷贝后：长stringWithFormat  testString_testString -> __NSCFString  -> 0x600000c29d70 -> 1
短stringWithFormat  a -> NSTaggedPointerString  -> 0x836cf15ab2175f4b -> 18446744073709551615
浅拷贝后：短stringWithFormat  a -> NSTaggedPointerString  -> 0x836cf15ab2175f4b -> 18446744073709551615
深拷贝后：短stringWithFormat  a -> __NSCFString  -> 0x600000c2a610 -> 1
长initWithFormat  testString_testString -> __NSCFString  -> 0x600000c38a80 -> 2
浅拷贝后：长initWithFormat  testString_testString -> __NSCFString  -> 0x600000c38a80 -> 3
深拷贝后：长initWithFormat  testString_testString -> __NSCFString  -> 0x600000c38930 -> 1
短initWithFormat  a -> NSTaggedPointerString  -> 0x836cf15ab2175f4b -> 18446744073709551615
浅拷贝后：短initWithFormat  a -> NSTaggedPointerString  -> 0x836cf15ab2175f4b -> 18446744073709551615
深拷贝后：短initWithFormat  a -> __NSCFString  -> 0x600000c34990 -> 1
```

通过日志总结一下结论：

1. **__NSCFConstantString** 和 **NSTaggedPointerString** copy后类型不变，地址不变
2. **__NSCFConstantString** 和 **NSTaggedPointerString** mutableCopy后类型都变成 **__NSCFString**，地址改变
3. **__NSCFString** copy后类型不变，内存地址不变，引用计数+1
4. **__NSCFString** mutableCopy后类型不变，内存地址改变