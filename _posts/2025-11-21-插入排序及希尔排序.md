---
layout:     post
title:      插入排序及希尔排序(Swift版本)
subtitle:   插入排序及希尔排序(Swift版本)
date:       2025-11-21
author:     LXY
header-img: img/home1.jpeg
catalog: true
tags:
    - 算法
---

## 插入排序
 插入排序（英语：Insertion Sort）
 是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
 
 Insertion Sort 和打扑克牌时，从牌桌上逐一拿起扑克牌，在手上排序的过程相同。

 **举例：**

 输入： {5 2 4 6 1 3}。

 - 首先拿起第一张牌, 手上有 {5}。

 - 拿起第二张牌 2, 把 2 insert 到手上的牌 {5}, 得到 {2 5}。

 - 拿起第三张牌 4, 把 4 insert 到手上的牌 {2 5}, 得到 {2 4 5}。

 - 以此类推。
 
 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

 1. 从第一个元素开始，该元素可以认为已经被排序
 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
 5. 将新元素插入到该位置后
 6. 重复步骤2~5
 

 如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需
 n−1次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有1/2n(n−1)次。插入排序的赋值操作是比较操作的次数减去n−1次，（因为n−1次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为
 O(n^2)。
 
 ### 代码
 
 ```
func insertionSort(_ array:inout [Int]){
    for i in 1..<array.count{
        var j = i-1
        let current = array[i]
        while j>=0,array[j]>current{
            array[j+1] = array[j]
            j-=1
        }
        array[j+1] = current
    }
}
 ```
 
 ## 希尔排序
 希尔排序（英语：Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。
 希尔排序是基于插入排序的以下两点性质而提出改进方法的：

 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
 而希尔排序在此基础上设计步长，每次移动步长位
 这样可以巧妙的利用插入排序针对(**长度短或顺序较为规律**)特点的数组效率高的特点
 
 ### 时间平均复杂度：
 O(n^1.3) 最坏复杂度:O(n^2) 最好复杂度: O(n) 空间复杂度: O(1) 不稳定
 
 
 
 ### 举例说明：
 比如有一份需要排序的数组为
 [7,6,5,44,3,6,7,8,55,3,9,2,7,4,1,22]
 
 插入排序的数组变化过程为
 
 ```
起始数组：[7, 6, 5, 44, 3, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[6, 7, 5, 44, 3, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[5, 6, 7, 44, 3, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[5, 6, 7, 44, 3, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[3, 5, 6, 7, 44, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[3, 5, 6, 6, 7, 44, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[3, 5, 6, 6, 7, 7, 44, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[3, 5, 6, 6, 7, 7, 8, 44, 55, 3, 9, 2, 7, 4, 1, 22]
[3, 5, 6, 6, 7, 7, 8, 44, 55, 3, 9, 2, 7, 4, 1, 22]
[3, 3, 5, 6, 6, 7, 7, 8, 44, 55, 9, 2, 7, 4, 1, 22]
[3, 3, 5, 6, 6, 7, 7, 8, 9, 44, 55, 2, 7, 4, 1, 22]
[2, 3, 3, 5, 6, 6, 7, 7, 8, 9, 44, 55, 7, 4, 1, 22]
[2, 3, 3, 5, 6, 6, 7, 7, 7, 8, 9, 44, 55, 4, 1, 22]
[2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 44, 55, 1, 22]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 44, 55, 22]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 44, 55]
结果数组：[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 44, 55]
 ```
希尔排序会根据步长分组，然后进行插入排序
默认步长是每次/2

 ### 直接log展示

 ```
 起始数组：[7, 6, 5, 44, 3, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
步长：8
[7, 6, 5, 44, 3, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[7, 3, 5, 44, 3, 6, 7, 8, 55, 6, 9, 2, 7, 4, 1, 22]
[7, 3, 5, 44, 3, 6, 7, 8, 55, 6, 9, 2, 7, 4, 1, 22]
[7, 3, 5, 2, 3, 6, 7, 8, 55, 6, 9, 44, 7, 4, 1, 22]
[7, 3, 5, 2, 3, 6, 7, 8, 55, 6, 9, 44, 7, 4, 1, 22]
[7, 3, 5, 2, 3, 4, 7, 8, 55, 6, 9, 44, 7, 6, 1, 22]
[7, 3, 5, 2, 3, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[7, 3, 5, 2, 3, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
步长：4
[3, 3, 5, 2, 7, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 5, 2, 7, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 9, 44, 55, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 9, 44, 55, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 7, 44, 55, 6, 9, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
步长：2
[1, 3, 3, 2, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 55, 22, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
步长：1
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 7, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 7, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 44, 55]
结果数组：[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 44, 55]
 ```
 
 ### log分析
 
 ***步长为8时***
 
 原始数组分为：
 
 ```
 [7,55] （index为：0，8）
 [6,3]（index为：1，9）
 [5,9]（index为：2，10）
 [44,2]（index为：3，11）
 [3,7]（index为：4，12）
 [6,4]（index为：5，13）
 [7,1]（index为：6，14）
 [8,22]（index为：7，15）
 ```
 然后针对每个子集进行插入排序
 
 ```
 步长：8
[7, 6, 5, 44, 3, 6, 7, 8, 55, 3, 9, 2, 7, 4, 1, 22]
[7, 3, 5, 44, 3, 6, 7, 8, 55, 6, 9, 2, 7, 4, 1, 22]
[7, 3, 5, 44, 3, 6, 7, 8, 55, 6, 9, 2, 7, 4, 1, 22]
[7, 3, 5, 2, 3, 6, 7, 8, 55, 6, 9, 44, 7, 4, 1, 22]
[7, 3, 5, 2, 3, 6, 7, 8, 55, 6, 9, 44, 7, 4, 1, 22]
[7, 3, 5, 2, 3, 4, 7, 8, 55, 6, 9, 44, 7, 6, 1, 22]
[7, 3, 5, 2, 3, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[7, 3, 5, 2, 3, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
 ```
 
  ***步长为4时***
 
 将操作后的数组分为：
 
 ```
 [7,3,55,7] （index为：0，4，8，12）
 [3,4,6,6]（index为：1，5，9，13）
 [5,1,9,7]（index为：2，6，10，14）
 [2,8,44,22]（index为：3，7，11，15）
 [3,55,7]（index为：4，8，12）
 [4,6,6]（index为：5，9，13）
 [1,9,7]（index为：6，10，14）
 [8,44,22]（index为：7，11，15）
 ```
 然后针对每个子集进行插入排序
 
 ```
步长：4
[3, 3, 5, 2, 7, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 5, 2, 7, 4, 1, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 55, 6, 9, 44, 7, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 9, 44, 55, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 9, 44, 55, 6, 7, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 7, 44, 55, 6, 9, 22]
[3, 3, 1, 2, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
 ```
 
   ***步长为2时***
 
 将操作后的数组分为：
 
 ```
[3, 1, 7, 5, 7, 7, 55, 9]（index为：0，2，4，6，8，10，12，14）
[3, 2, 4, 8, 6, 22, 6, 44]（index为：1，3，5，7，9，11，13，15）
 ```
 然后针对每个子集进行插入排序
 
 ```
步长：2
[1, 3, 3, 2, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 7, 4, 5, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 8, 7, 6, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 8, 7, 22, 55, 6, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 55, 22, 9, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
 ```
 
  ***步长为1时***

 
 
 ```
步长：1
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 5, 4, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 7, 6, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 7, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 7, 7, 6, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 55, 44]
[1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 7, 8, 9, 22, 44, 55]
 ```

 
 ### 代码推导
 
 **插入排序是可以理解为步数为1的希尔排序，将这个1从插入排序的代码中提出来**
 
 
 ```
 ///>插入排序
 func insertionSort(_ array:inout [Int]){
    for i in 1..<array.count{
        var j = i-1
        let current = array[i]
        while j>=0,array[j]>current{
            array[j+1] = array[j]
            j-=1
        }
        array[j+1] = current
    }
}
```
 
 ```
///>步数为1的希尔排序
func insertionSortStep(_ array:inout [Int]){
    let step = 1
    for i in step..<array.count{
        var j = i-step
        let current = array[i]
        while j>=0,array[j]>current{
            array[j+step] = array[j]
            j-=step
        }
        array[j+step] = current
    }
}
 ```
 
  **步数为动态变化的插入排序即为希尔排序**
  
  ```
func shellSort(_ array:inout [Int]){
    var step = array.count/2
    while step>=1{
        print("步长：\(step)")
        for i in step..<array.count{
            var j = i-step
            let current = array[i]
            while j>=0,array[j]>current{
                array[j+step] = array[j]
                j-=step
            }
            array[j+step] = current
            
            print(array)
        }
        
        step = step/2
    }
}
 ```
 
 
 
